import { parse } from './parser'; // generated by peggy from parser.peggy

// ---------- AST Types (mirror the grammar; keep minimal) ----------
type Id = `#${string}`;

type RoleSelector = {
  type: 'Selector';
  mode: 'role';
  role: string;           // any ARIA role, or the specials: field | image | text
  name: string | null;    // the quoted name after role
  id?: Id;                // optional "#id" suffix (rare; see note below)
};

type TagSelector = {
  type: 'Selector';
  mode: 'tag';
  tag: string;            // e.g., section, form, button
  id?: Id;                // optional "#id" suffix
};

type IdOnlySelector = {
  type: 'Selector';
  mode: 'idonly';
  id: Id;                 // e.g., "#main"
};

type RawSelector = {
  type: 'Selector';
  mode: 'raw';
  raw: string;            // backticked Playwright selector, without the backticks
};

type Selector = RoleSelector | TagSelector | IdOnlySelector | RawSelector;

type Predicate = { type: 'HasDescendant'; selector: Selector };

type WithExpr = {
  type: 'With';
  selector: Selector;
  include: Predicate[];   // from `with <selector>`
  exclude: Predicate[];   // from `without <selector>`
};

type Expr = {
  type: 'Within';
  base: WithExpr;
  ancestors: Selector[];  // outermost → innermost containers from chained `within`
};

// ---------- Escapers: same semantics as your snippet ----------
function escapeRegexForSelector(re: RegExp): string {
  // keep unicode flags as-is; otherwise escape quotes and >> combinators
  // @ts-ignore - .unicodeSets may exist on some runtimes
  if (re.unicode || (re as any).unicodeSets) return String(re);
  return String(re)
    .replace(/(^|[^\\])(\\\\)*(["'`])/g, '$1$2\\$3')
    .replace(/>>/g, '\\>\\>');
}

function escapeForTextSelector(text: string | RegExp, exact = false): string {
  if (typeof text !== 'string') return escapeRegexForSelector(text);
  return `${JSON.stringify(text)}${exact ? 's' : 'i'}`;
}

function escapeForAttributeSelector(value: string | RegExp, exact = false): string {
  if (typeof value !== 'string') return escapeRegexForSelector(value);
  return `"${value.replace(/\\/g, '\\\\').replace(/["]/g, '\\"')}"${exact ? 's' : 'i'}`;
}

// ---------- Builders for internal engines ----------
function getByAttributeTextSelector(attrName: string, text: string | RegExp, props = ''): string {
  return `internal:attr=[${attrName}=${escapeForAttributeSelector(text)}]` + (props ? ` ${props}` : '');
}

function getByAltTextSelector(text: string | RegExp, props = ''): string {
  return getByAttributeTextSelector('alt', text, props);
}

function getByLabelSelector(text: string | RegExp, props = ''): string {
  return 'internal:label=' + escapeForTextSelector(text) + (props ? ` ${props}` : '');
}

function getByTextSelector(text: string | RegExp, props = ''): string {
  return 'internal:text=' + escapeForTextSelector(text) + (props ? ` ${props}` : '');
}

function getByRoleSelector(role: string, name: string | RegExp = '', props = ''): string {
  return `internal:role=${role}` + (name ? ` [name=${escapeForAttributeSelector(name)}]` : '') + (props ? ` ${props}` : '');
}

// ---------- Core compile helpers ----------
/**
 * Compile a base selector (no predicates, no ancestors).
 * Notes:
 * - For tag + id, we emit `tag#id`.
 * - For role + id (rare in your DSL), we **scope** it as `#id >> internal:role=...`
 *   because Playwright engines can’t intersect "same element" across engines in one token.
 */
function compileBaseSelector(sel: Selector): string {
  switch (sel.mode) {
    case 'raw':
      return sel.raw;
    case 'idonly':
      return sel.id;
    case 'tag':
      return sel.id ? `${sel.tag}${sel.id}` : sel.tag;
    case 'role': {
      const r = sel.role.toLowerCase();
      if (r === 'field') {
        if (!sel.name) throw new Error('`field` requires a label string: field "Name"');
        const s = getByLabelSelector(sel.name);
        return sel.id ? `${sel.id} >> ${s}` : s;
      }
      if (r === 'image') {
        if (!sel.name) throw new Error('`image` requires an alt string: image "Logo"');
        const s = getByAltTextSelector(sel.name);
        return sel.id ? `${sel.id} >> ${s}` : s;
      }
      if (r === 'text') {
        if (!sel.name) throw new Error('`text` requires a string: text "Hello"');
        const s = getByTextSelector(sel.name);
        return sel.id ? `${sel.id} >> ${s}` : s;
      }
      // Generic ARIA role
      const s = getByRoleSelector(r, sel.name ?? '');
      return sel.id ? `${sel.id} >> ${s}` : s;
    }
  }
}

/**
 * Compile a predicate into ` >> internal:has=...` or ` >> internal:has-not=...`.
 * We always use the general `internal:has` flavor and stringify the *inner* selector chain,
 * which matches the constructor pattern you showed.
 */
function compilePredicates(include: Predicate[], exclude: Predicate[]): string {
  const parts: string[] = [];

  for (const p of include) {
    const inner = compileBaseSelector(p.selector);
    parts.push(`>> internal:has="${inner}"`);
  }
  for (const p of exclude) {
    const inner = compileBaseSelector(p.selector);
    parts.push(`>> internal:has-not="${inner}"`);
  }
  return parts.length ? ' ' + parts.join(' ') : '';
}

/**
 * Join a chain with Playwright’s engine combinator.
 */
function joinChain(parts: string[]): string {
  return parts.filter(Boolean).join(' >> ');
}

/**
 * Public API: compile a DSL locator string into a Playwright selector string.
 */
export function compileLocator(input: string): string {
  const ast = parse(input) as Expr;

  // 1) compile ancestor containers (outer → inner)
  const chain: string[] = ast.ancestors.map(compileBaseSelector);

  // 2) compile base
  const base = compileBaseSelector(ast.base.selector);

  // 3) add predicates to the *base* (they apply to the current rightmost selector)
  const pred = compilePredicates(ast.base.include, ast.base.exclude);

  // 4) build final chain
  let selector = joinChain([...chain, base]);
  if (pred) selector += ' ' + pred.trim();

  return selector;
}
